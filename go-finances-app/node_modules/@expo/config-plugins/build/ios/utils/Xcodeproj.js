"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNotComment = exports.isNotTestHost = exports.isBuildConfig = exports.getBuildConfigurationForListIdAndName = exports.getBuildConfigurationsForListId = exports.getXCConfigurationListEntries = exports.getProjectSection = exports.getProductName = exports.getPbxproj = exports.ensureGroupRecursively = exports.addFramework = exports.getApplicationNativeTarget = exports.addFileToGroupAndLink = exports.addBuildSourceFileToGroup = exports.addResourceFileToGroup = exports.getHackyProjectName = exports.getProjectName = void 0;
const assert_1 = __importDefault(require("assert"));
const path_1 = __importDefault(require("path"));
const xcode_1 = __importDefault(require("xcode"));
const pbxFile_1 = __importDefault(require("xcode/lib/pbxFile"));
const warnings_1 = require("../../utils/warnings");
const Paths = __importStar(require("../Paths"));
function getProjectName(projectRoot) {
    const sourceRoot = Paths.getSourceRoot(projectRoot);
    return path_1.default.basename(sourceRoot);
}
exports.getProjectName = getProjectName;
// TODO: come up with a better solution for using app.json expo.name in various places
function sanitizedName(name) {
    return name
        .replace(/[\W_]+/g, '')
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');
}
// TODO: it's silly and kind of fragile that we look at app config to determine
// the ios project paths. Overall this function needs to be revamped, just a
// placeholder for now! Make this more robust when we support applying config
// at any time (currently it's only applied on eject).
function getHackyProjectName(projectRoot, config) {
    // Attempt to get the current ios folder name (apply).
    try {
        return getProjectName(projectRoot);
    }
    catch {
        // If no iOS project exists then create a new one (eject).
        const projectName = config.name;
        assert_1.default(projectName, 'Your project needs a name in app.json/app.config.js.');
        return sanitizedName(projectName);
    }
}
exports.getHackyProjectName = getHackyProjectName;
function createProjectFileForGroup({ filepath, group }) {
    const file = new pbxFile_1.default(filepath);
    const conflictingFile = group.children.find(child => child.comment === file.basename);
    if (conflictingFile) {
        // This can happen when a file like the GoogleService-Info.plist needs to be added and the eject command is run twice.
        // Not much we can do here since it might be a conflicting file.
        return null;
    }
    return file;
}
/**
 * Add a resource file (ex: `SplashScreen.storyboard`, `Images.xcassets`) to an Xcode project.
 * This is akin to creating a new code file in Xcode with `⌘+n`.
 */
function addResourceFileToGroup({ filepath, groupName, 
// Should add to `PBXBuildFile Section`
isBuildFile, project, }) {
    return addFileToGroupAndLink({
        filepath,
        groupName,
        project,
        addFileToProject({ project, file }) {
            project.addToPbxFileReferenceSection(file);
            if (isBuildFile) {
                project.addToPbxBuildFileSection(file);
            }
            project.addToPbxResourcesBuildPhase(file);
        },
    });
}
exports.addResourceFileToGroup = addResourceFileToGroup;
/**
 * Add a build source file (ex: `AppDelegate.m`, `ViewController.swift`) to an Xcode project.
 * This is akin to creating a new code file in Xcode with `⌘+n`.
 */
function addBuildSourceFileToGroup({ filepath, groupName, project, }) {
    return addFileToGroupAndLink({
        filepath,
        groupName,
        project,
        addFileToProject({ project, file }) {
            project.addToPbxFileReferenceSection(file);
            project.addToPbxBuildFileSection(file);
            project.addToPbxSourcesBuildPhase(file);
        },
    });
}
exports.addBuildSourceFileToGroup = addBuildSourceFileToGroup;
// TODO(brentvatne): I couldn't figure out how to do this with an existing
// higher level function exposed by the xcode library, but we should find out how to do
// that and replace this with it
function addFileToGroupAndLink({ filepath, groupName, project, addFileToProject, }) {
    const group = pbxGroupByPathOrAssert(project, groupName);
    const file = createProjectFileForGroup({ filepath, group });
    if (!file) {
        // This can happen when a file like the GoogleService-Info.plist needs to be added and the eject command is run twice.
        // Not much we can do here since it might be a conflicting file.
        warnings_1.addWarningIOS('ios-xcode-project', `Skipped adding duplicate file "${filepath}" to PBXGroup named "${groupName}"`);
        return project;
    }
    file.uuid = project.generateUuid();
    file.fileRef = project.generateUuid();
    addFileToProject({ project, file });
    group.children.push({
        value: file.fileRef,
        comment: file.basename,
    });
    return project;
}
exports.addFileToGroupAndLink = addFileToGroupAndLink;
function getApplicationNativeTarget({ project, projectName, }) {
    const applicationNativeTarget = project.getTarget('com.apple.product-type.application');
    assert_1.default(applicationNativeTarget, `Couldn't locate application PBXNativeTarget in '.xcodeproj' file.`);
    assert_1.default(String(applicationNativeTarget.target.name) === projectName, `Application native target name mismatch. Expected ${projectName}, but found ${applicationNativeTarget.target.name}.`);
    return applicationNativeTarget;
}
exports.getApplicationNativeTarget = getApplicationNativeTarget;
/**
 * Add a framework to the default app native target.
 *
 * @param projectName Name of the PBX project.
 * @param framework String ending in `.framework`, i.e. `StoreKit.framework`
 */
function addFramework({ project, projectName, framework, }) {
    const target = getApplicationNativeTarget({ project, projectName });
    return project.addFramework(framework, { target: target.uuid });
}
exports.addFramework = addFramework;
function splitPath(path) {
    // TODO: Should we account for other platforms that may not use `/`
    return path.split('/');
}
const findGroup = (group, name) => {
    if (!group) {
        return undefined;
    }
    return group.children.find(group => group.comment === name);
};
function findGroupInsideGroup(project, group, name) {
    var _a;
    const foundGroup = findGroup(group, name);
    if (foundGroup) {
        return (_a = project.getPBXGroupByKey(foundGroup.value)) !== null && _a !== void 0 ? _a : null;
    }
    return null;
}
function pbxGroupByPathOrAssert(project, path) {
    const { firstProject } = project.getFirstProject();
    let group = project.getPBXGroupByKey(firstProject.mainGroup);
    const components = splitPath(path);
    for (const name of components) {
        const nextGroup = findGroupInsideGroup(project, group, name);
        if (nextGroup) {
            group = nextGroup;
        }
        else {
            break;
        }
    }
    if (!group) {
        throw Error(`Xcode PBXGroup with name "${path}" could not be found in the Xcode project.`);
    }
    return group;
}
function ensureGroupRecursively(project, filepath) {
    const components = splitPath(filepath);
    const hasChild = (group, name) => group.children.find(({ comment }) => comment === name);
    const { firstProject } = project.getFirstProject();
    let topMostGroup = project.getPBXGroupByKey(firstProject.mainGroup);
    for (const pathComponent of components) {
        if (topMostGroup && !hasChild(topMostGroup, pathComponent)) {
            topMostGroup.children.push({
                comment: pathComponent,
                value: project.pbxCreateGroup(pathComponent, '""'),
            });
        }
        topMostGroup = project.pbxGroupByName(pathComponent);
    }
    return topMostGroup !== null && topMostGroup !== void 0 ? topMostGroup : null;
}
exports.ensureGroupRecursively = ensureGroupRecursively;
/**
 * Get the pbxproj for the given path
 */
function getPbxproj(projectRoot) {
    const projectPath = Paths.getPBXProjectPath(projectRoot);
    const project = xcode_1.default.project(projectPath);
    project.parseSync();
    return project;
}
exports.getPbxproj = getPbxproj;
/**
 * Get the productName for a project, if the name is using a variable `$(TARGET_NAME)`, then attempt to get the value of that variable.
 *
 * @param project
 */
function getProductName(project) {
    var _a, _b;
    let productName = '$(TARGET_NAME)';
    try {
        // If the product name is numeric, this will fail (it's a getter).
        // If the bundle identifier' final component is only numeric values, then the PRODUCT_NAME
        // will be a numeric value, this results in a bug where the product name isn't useful,
        // i.e. `com.bacon.001` -> `1` -- in this case, use the first target name.
        productName = project.productName;
    }
    catch { }
    if (productName === '$(TARGET_NAME)') {
        const targetName = (_b = (_a = project.getFirstTarget()) === null || _a === void 0 ? void 0 : _a.firstTarget) === null || _b === void 0 ? void 0 : _b.productName;
        productName = targetName !== null && targetName !== void 0 ? targetName : productName;
    }
    return productName;
}
exports.getProductName = getProductName;
function getProjectSection(project) {
    return project.pbxProjectSection();
}
exports.getProjectSection = getProjectSection;
function getXCConfigurationListEntries(project) {
    const lists = project.pbxXCConfigurationList();
    return Object.entries(lists).filter(isNotComment);
}
exports.getXCConfigurationListEntries = getXCConfigurationListEntries;
function getBuildConfigurationsForListId(project, configurationListId) {
    const configurationListEntries = getXCConfigurationListEntries(project);
    const [, configurationList] = configurationListEntries.find(([key]) => key === configurationListId);
    const buildConfigurations = configurationList.buildConfigurations.map(i => i.value);
    return Object.entries(project.pbxXCBuildConfigurationSection())
        .filter(isNotComment)
        .filter(isBuildConfig)
        .filter(isNotTestHost)
        .filter(([key]) => buildConfigurations.includes(key));
}
exports.getBuildConfigurationsForListId = getBuildConfigurationsForListId;
function getBuildConfigurationForListIdAndName(project, { configurationListId, buildConfiguration, }) {
    const xcBuildConfigurationEntry = getBuildConfigurationsForListId(project, configurationListId).find(i => i[1].name === buildConfiguration);
    if (!xcBuildConfigurationEntry) {
        throw new Error(`Build configuration '${buildConfiguration} does not exist in list with id '${configurationListId}'`);
    }
    return xcBuildConfigurationEntry;
}
exports.getBuildConfigurationForListIdAndName = getBuildConfigurationForListIdAndName;
function isBuildConfig([, sectionItem]) {
    return sectionItem.isa === 'XCBuildConfiguration';
}
exports.isBuildConfig = isBuildConfig;
function isNotTestHost([, sectionItem]) {
    return !sectionItem.buildSettings.TEST_HOST;
}
exports.isNotTestHost = isNotTestHost;
function isNotComment([key]) {
    return !key.endsWith(`_comment`);
}
exports.isNotComment = isNotComment;
//# sourceMappingURL=Xcodeproj.js.map