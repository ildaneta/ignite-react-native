{"version":3,"file":"withStaticPlugin.js","sourceRoot":"","sources":["../../src/plugins/withStaticPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport { boolish } from 'getenv';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\nimport {\n  assertInternalProjectRoot,\n  normalizeStaticPlugin,\n  resolveConfigPluginFunction,\n} from '../utils/plugin-resolver';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\nconst EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = boolish('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\n\nfunction isModuleMissingError(name: string, error: Error): boolean {\n  // @ts-ignore\n  if (['MODULE_NOT_FOUND', 'PLUGIN_NOT_FOUND'].includes(error.code)) {\n    return true;\n  }\n  return error.message.includes(`Cannot find module '${name}'`);\n}\n\nfunction isUnexpectedTokenError(error: Error): boolean {\n  if (\n    error instanceof SyntaxError ||\n    (error instanceof PluginError && error.code === 'INVALID_PLUGIN_IMPORT')\n  ) {\n    return (\n      // These are the most common errors that'll be thrown when a package isn't transpiled correctly.\n      !!error.message.match(/Unexpected token/) ||\n      !!error.message.match(/Cannot use import statement/)\n    );\n  }\n  return false;\n}\n\n/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n * @param _isLegacyPlugin Used to suppress errors thrown by plugins that are applied automatically\n */\nexport const withStaticPlugin: ConfigPlugin<{\n  plugin: StaticPlugin | ConfigPlugin | string;\n  fallback?: ConfigPlugin<{ _resolverError: Error } & any>;\n  projectRoot?: string;\n  _isLegacyPlugin?: boolean;\n}> = (config, props) => {\n  let projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    projectRoot = config._internal?.projectRoot;\n    assertInternalProjectRoot(projectRoot);\n  }\n\n  let [pluginResolve, pluginProps] = normalizeStaticPlugin(props.plugin);\n  // Ensure no one uses this property by accident.\n  assert(\n    !pluginProps?._resolverError,\n    `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``\n  );\n\n  let withPlugin: ConfigPlugin<unknown>;\n  // Function was provided, no need to resolve: [withPlugin, {}]\n  if (typeof pluginResolve === 'function') {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      // Resolve and evaluate plugins.\n      withPlugin = resolveConfigPluginFunction(projectRoot, pluginResolve);\n    } catch (error) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n          console.log(`Error resolving plugin \"${pluginResolve}\"`);\n          console.log(error);\n          console.log();\n        } else {\n          const shouldMuteWarning =\n            props._isLegacyPlugin &&\n            (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              // Prevent causing log spew for basic resolution errors.\n              console.log(`Could not find plugin \"${pluginResolve}\"`);\n            } else {\n              // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n              console.log(`Error resolving plugin \"${pluginResolve}\"`);\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n      // TODO: Maybe allow for `PluginError`s to be thrown so external plugins can assert invalid options.\n\n      // If the static module failed to resolve, attempt to use a fallback.\n      // This enables support for built-in plugins with versioned variations living in other packages.\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        // Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        // If no fallback, throw the resolution error.\n        throw error;\n      }\n    }\n  } else {\n    throw new PluginError(\n      `Plugin is an unexpected type: ${typeof pluginResolve}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n  // Execute the plugin.\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n"]}