"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIosIntrospectModFileProviders = exports.getIosModFileProviders = exports.withIosBaseMods = void 0;
const plist_1 = __importDefault(require("@expo/plist"));
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const xcode_1 = __importDefault(require("xcode"));
const ios_1 = require("../ios");
const createBaseMod_1 = require("./createBaseMod");
const { readFile, writeFile } = fs_1.promises;
const defaultProviders = {
    dangerous: createBaseMod_1.provider({
        getFilePath() {
            return '';
        },
        async read() {
            return {};
        },
        async write() { },
    }),
    // Append a rule to supply AppDelegate data to mods on `mods.ios.appDelegate`
    appDelegate: createBaseMod_1.provider({
        getFilePath({ modRequest: { projectRoot } }) {
            return ios_1.Paths.getAppDelegateFilePath(projectRoot);
        },
        async read(filePath) {
            return ios_1.Paths.getFileInfo(filePath);
        },
        async write(filePath, { modResults: { contents } }) {
            await writeFile(filePath, contents);
        },
    }),
    // Append a rule to supply Expo.plist data to mods on `mods.ios.expoPlist`
    expoPlist: createBaseMod_1.provider({
        getFilePath({ modRequest: { platformProjectRoot, projectName } }) {
            const supportingDirectory = path_1.default.join(platformProjectRoot, projectName, 'Supporting');
            return path_1.default.resolve(supportingDirectory, 'Expo.plist');
        },
        async read(filePath) {
            return plist_1.default.parse(await readFile(filePath, 'utf8'));
        },
        async write(filePath, { modResults }) {
            await writeFile(filePath, plist_1.default.build(modResults));
        },
    }),
    // Append a rule to supply .xcodeproj data to mods on `mods.ios.xcodeproj`
    xcodeproj: createBaseMod_1.provider({
        getFilePath({ modRequest: { projectRoot } }) {
            return ios_1.Paths.getPBXProjectPath(projectRoot);
        },
        async read(filePath) {
            const project = xcode_1.default.project(filePath);
            project.parseSync();
            return project;
        },
        async write(filePath, { modResults }) {
            await writeFile(filePath, modResults.writeSync());
        },
    }),
    // Append a rule to supply Info.plist data to mods on `mods.ios.infoPlist`
    infoPlist: createBaseMod_1.provider({
        getFilePath(config) {
            return ios_1.Paths.getInfoPlistPath(config.modRequest.projectRoot);
        },
        async read(filePath, config) {
            // Apply all of the Info.plist values to the expo.ios.infoPlist object
            // TODO: Remove this in favor of just overwriting the Info.plist with the Expo object. This will enable people to actually remove values.
            if (!config.ios)
                config.ios = {};
            if (!config.ios.infoPlist)
                config.ios.infoPlist = {};
            const contents = await readFile(filePath, 'utf8');
            assert_1.default(contents, 'Info.plist is empty');
            const modResults = plist_1.default.parse(contents);
            config.ios.infoPlist = {
                ...(modResults || {}),
                ...config.ios.infoPlist,
            };
            return modResults;
        },
        async write(filePath, config) {
            // Update the contents of the static infoPlist object
            if (!config.ios)
                config.ios = {};
            config.ios.infoPlist = config.modResults;
            await writeFile(filePath, plist_1.default.build(config.modResults));
        },
    }),
    // Append a rule to supply .entitlements data to mods on `mods.ios.entitlements`
    entitlements: createBaseMod_1.provider({
        getFilePath(config) {
            return ios_1.Entitlements.getEntitlementsPath(config.modRequest.projectRoot);
        },
        async read(filePath, config) {
            const contents = await readFile(filePath, 'utf8');
            assert_1.default(contents, 'Entitlements plist is empty');
            const modResults = plist_1.default.parse(contents);
            // Apply all of the .entitlements values to the expo.ios.entitlements object
            // TODO: Remove this in favor of just overwriting the .entitlements with the Expo object. This will enable people to actually remove values.
            if (!config.ios)
                config.ios = {};
            if (!config.ios.entitlements)
                config.ios.entitlements = {};
            config.ios.entitlements = {
                ...(modResults || {}),
                ...config.ios.entitlements,
            };
            return modResults;
        },
        async write(filePath, config) {
            // Update the contents of the static entitlements object
            if (!config.ios) {
                config.ios = {};
            }
            config.ios.entitlements = config.modResults;
            await writeFile(filePath, plist_1.default.build(config.modResults));
        },
    }),
};
function withIosBaseMods(config, { providers, ...props } = {}) {
    return createBaseMod_1.withGeneratedBaseMods(config, {
        ...props,
        platform: 'ios',
        providers: providers !== null && providers !== void 0 ? providers : getIosModFileProviders(),
    });
}
exports.withIosBaseMods = withIosBaseMods;
function getIosModFileProviders() {
    return defaultProviders;
}
exports.getIosModFileProviders = getIosModFileProviders;
/**
 * Get file providers that run introspection without modifying the actual native source code.
 * This can be used to determine the absolute static `ios.infoPlist` and `ios.entitlements` objects.
 *
 * @returns
 */
function getIosIntrospectModFileProviders() {
    const createIntrospectionProvider = (modName, { fallbackContents }) => {
        const realProvider = defaultProviders[modName];
        return createBaseMod_1.provider({
            async getFilePath(...props) {
                try {
                    return await realProvider.getFilePath(...props);
                }
                catch {
                    // fallback to an empty string in introspection mode.
                    return '';
                }
            },
            async read(...props) {
                try {
                    return await realProvider.read(...props);
                }
                catch {
                    // fallback if a file is missing in introspection mode.
                    return fallbackContents;
                }
            },
            async write() {
                // write nothing in introspection mode.
            },
        });
    };
    // dangerous should never be added
    return {
        // appDelegate: createIntrospectionProvider('appDelegate', {
        //   fallbackContents: {
        //     path: '',
        //     contents: '',
        //     language: 'objc',
        //   } as Paths.AppDelegateProjectFile,
        // }),
        // xcodeproj: createIntrospectionProvider('xcodeproj', {
        //   fallbackContents: {} as XcodeProject,
        // }),
        expoPlist: createIntrospectionProvider('expoPlist', {
            fallbackContents: {},
        }),
        infoPlist: {
            async getFilePath(...props) {
                try {
                    return await defaultProviders.infoPlist.getFilePath(...props);
                }
                catch {
                    return '';
                }
            },
            async read(filePath, config, props) {
                var _a, _b;
                try {
                    return await defaultProviders.infoPlist.read(filePath, config, props);
                }
                catch {
                    // Fallback to using the infoPlist object from the Expo config.
                    return ((_b = (_a = config.ios) === null || _a === void 0 ? void 0 : _a.infoPlist) !== null && _b !== void 0 ? _b : {
                        CFBundleDevelopmentRegion: '$(DEVELOPMENT_LANGUAGE)',
                        CFBundleExecutable: '$(EXECUTABLE_NAME)',
                        CFBundleIdentifier: '$(PRODUCT_BUNDLE_IDENTIFIER)',
                        CFBundleName: '$(PRODUCT_NAME)',
                        CFBundlePackageType: '$(PRODUCT_BUNDLE_PACKAGE_TYPE)',
                        CFBundleInfoDictionaryVersion: '6.0',
                        CFBundleSignature: '????',
                        LSRequiresIPhoneOS: true,
                        NSAppTransportSecurity: {
                            NSAllowsArbitraryLoads: true,
                            NSExceptionDomains: {
                                localhost: {
                                    NSExceptionAllowsInsecureHTTPLoads: true,
                                },
                            },
                        },
                        UILaunchStoryboardName: 'SplashScreen',
                        UIRequiredDeviceCapabilities: ['armv7'],
                        UIViewControllerBasedStatusBarAppearance: false,
                        UIStatusBarStyle: 'UIStatusBarStyleDefault',
                    });
                }
            },
            write(filePath, config) {
                // Update the contents of the static infoPlist object
                if (!config.ios)
                    config.ios = {};
                config.ios.infoPlist = config.modResults;
            },
        },
        entitlements: {
            async getFilePath(...props) {
                try {
                    return await defaultProviders.entitlements.getFilePath(...props);
                }
                catch {
                    return '';
                }
            },
            async read(filePath, config, props) {
                var _a, _b;
                try {
                    return await defaultProviders.entitlements.read(filePath, config, props);
                }
                catch {
                    // Fallback to using the entitlements object from the Expo config.
                    return (_b = (_a = config.ios) === null || _a === void 0 ? void 0 : _a.entitlements) !== null && _b !== void 0 ? _b : {};
                }
            },
            write(filePath, config) {
                // Update the contents of the static entitlements object
                if (!config.ios)
                    config.ios = {};
                config.ios.entitlements = config.modResults;
            },
        },
    };
}
exports.getIosIntrospectModFileProviders = getIosIntrospectModFileProviders;
//# sourceMappingURL=withIosBaseMods.js.map