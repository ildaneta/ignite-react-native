{"version":3,"file":"createBaseMod.js","sourceRoot":"","sources":["../../src/plugins/createBaseMod.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ConfigPlugin,\n  ExportedConfig,\n  ExportedConfigWithProps,\n  ModPlatform,\n} from '../Plugin.types';\nimport { BaseModOptions, withBaseMod } from './withMod';\n\nexport type ForwardedBaseModOptions = Partial<\n  Pick<BaseModOptions, 'saveToInternal' | 'skipEmptyMod'>\n>;\n\nexport type BaseModProviderMethods<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  getFilePath: (config: ExportedConfigWithProps<ModType>, props: Props) => Promise<string> | string;\n  read: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<ModType> | ModType;\n  write: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<void> | void;\n};\n\nexport type CreateBaseModProps<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  methodName: string;\n  platform: ModPlatform;\n  modName: string;\n} & BaseModProviderMethods<ModType, Props>;\n\nexport function createBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({\n  methodName,\n  platform,\n  modName,\n  getFilePath,\n  read,\n  write,\n}: CreateBaseModProps<ModType, Props>): ConfigPlugin<Props | void> {\n  const withUnknown: ConfigPlugin<Props | void> = (config, _props) => {\n    const props = _props || ({} as Props);\n    return withBaseMod<ModType>(config, {\n      platform,\n      mod: modName,\n      skipEmptyMod: props.skipEmptyMod ?? true,\n      saveToInternal: props.saveToInternal ?? false,\n      isProvider: true,\n      async action({ modRequest: { nextMod, ...modRequest }, ...config }) {\n        try {\n          let results: ExportedConfigWithProps<ModType> = {\n            ...config,\n            modRequest,\n          };\n\n          const filePath = await getFilePath(results, props);\n\n          const modResults = await read(filePath, results, props);\n\n          results = await nextMod!({\n            ...results,\n            modResults,\n            modRequest,\n          });\n\n          assertModResults(results, modRequest.platform, modRequest.modName);\n\n          await write(filePath, results, props);\n          return results;\n        } catch (error) {\n          error.message = `[${platform}.${modName}]: ${methodName}: ${error.message}`;\n          throw error;\n        }\n      },\n    });\n  };\n\n  if (methodName) {\n    Object.defineProperty(withUnknown, 'name', {\n      value: methodName,\n    });\n  }\n\n  return withUnknown;\n}\n\nexport function assertModResults(results: any, platformName: string, modName: string) {\n  // If the results came from a mod, they'd be in the form of [config, data].\n  // Ensure the results are an array and omit the data since it should've been written by a data provider plugin.\n  const ensuredResults = results;\n\n  // Sanity check to help locate non compliant mods.\n  if (!ensuredResults || typeof ensuredResults !== 'object' || !ensuredResults?.mods) {\n    throw new Error(\n      `Mod \\`mods.${platformName}.${modName}\\` evaluated to an object that is not a valid project config. Instead got: ${JSON.stringify(\n        ensuredResults\n      )}`\n    );\n  }\n  return ensuredResults;\n}\n\nfunction upperFirst(name: string): string {\n  return name.charAt(0).toUpperCase() + name.slice(1);\n}\n\nexport function createPlatformBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({ modName, ...props }: Omit<CreateBaseModProps<ModType, Props>, 'methodName'>) {\n  // Generate the function name to ensure it's uniform and also to improve stack traces.\n  const methodName = `with${upperFirst(props.platform)}${upperFirst(modName)}BaseMod`;\n  return createBaseMod<ModType, Props>({\n    methodName,\n    modName,\n    ...props,\n  });\n}\n\nexport function provider<ModType, Props extends ForwardedBaseModOptions = ForwardedBaseModOptions>(\n  props: BaseModProviderMethods<ModType, Props>\n) {\n  return props;\n}\n\nexport function withGeneratedBaseMods<ModName extends string>(\n  config: ExportedConfig,\n  {\n    platform,\n    providers,\n    ...props\n  }: ForwardedBaseModOptions & {\n    platform: ModPlatform;\n    providers: Partial<Record<ModName, BaseModProviderMethods<any, any>>>;\n  }\n): ExportedConfig {\n  return Object.entries(providers).reduce((config, [modName, value]) => {\n    const baseMod = createPlatformBaseMod({ platform, modName, ...(value as any) });\n    return baseMod(config, props);\n  }, config);\n}\n"]}