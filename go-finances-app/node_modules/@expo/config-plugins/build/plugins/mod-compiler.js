"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.evalModsAsync = exports.compileModsAsync = exports.withIntrospectionBaseMods = exports.withDefaultBaseMods = void 0;
const path_1 = __importDefault(require("path"));
const Xcodeproj_1 = require("../ios/utils/Xcodeproj");
const errors_1 = require("../utils/errors");
const createBaseMod_1 = require("./createBaseMod");
const withAndroidBaseMods_1 = require("./withAndroidBaseMods");
const withIosBaseMods_1 = require("./withIosBaseMods");
function withDefaultBaseMods(config, props = {}) {
    config = withIosBaseMods_1.withIosBaseMods(config, props);
    config = withAndroidBaseMods_1.withAndroidBaseMods(config, props);
    return config;
}
exports.withDefaultBaseMods = withDefaultBaseMods;
/**
 * Get a prebuild config that safely evaluates mods without persisting any changes to the file system.
 * Currently this only supports infoPlist, entitlements, androidManifest, strings, gradleProperties, and expoPlist mods.
 * This plugin should be evaluated directly:
 */
function withIntrospectionBaseMods(config, props = {}) {
    const iosProviders = withIosBaseMods_1.getIosIntrospectModFileProviders();
    const androidProviders = withAndroidBaseMods_1.getAndroidIntrospectModFileProviders();
    config = withIosBaseMods_1.withIosBaseMods(config, {
        providers: iosProviders,
        saveToInternal: true,
        // This writing optimization can be skipped since we never write in introspection mode.
        // Including empty mods will ensure that all mods get introspected.
        skipEmptyMod: false,
        ...props,
    });
    config = withAndroidBaseMods_1.withAndroidBaseMods(config, {
        providers: androidProviders,
        saveToInternal: true,
        skipEmptyMod: false,
        ...props,
    });
    const preserve = {
        ios: Object.keys(iosProviders),
        android: Object.keys(androidProviders),
    };
    if (config.mods) {
        // Remove all mods that don't have an introspection base mod, for instance `dangerous` mods.
        for (const platform of Object.keys(config.mods)) {
            if (!(platform in preserve)) {
                delete config.mods[platform];
            }
            const platformPreserve = preserve[platform];
            for (const key of Object.keys(config.mods[platform] || {})) {
                if (!(platformPreserve === null || platformPreserve === void 0 ? void 0 : platformPreserve.includes(key))) {
                    // @ts-ignore
                    delete config.mods[platform][key];
                }
            }
        }
    }
    return config;
}
exports.withIntrospectionBaseMods = withIntrospectionBaseMods;
/**
 *
 * @param projectRoot
 * @param config
 */
async function compileModsAsync(config, props) {
    if (props.introspect === true) {
        config = withIntrospectionBaseMods(config);
    }
    else {
        config = withDefaultBaseMods(config);
    }
    return await evalModsAsync(config, props);
}
exports.compileModsAsync = compileModsAsync;
function sortMods(commands, order) {
    const allKeys = commands.map(([key]) => key);
    const completeOrder = [...new Set([...order, ...allKeys])];
    const sorted = [];
    while (completeOrder.length) {
        const group = completeOrder.shift();
        const commandSet = commands.find(([key]) => key === group);
        if (commandSet) {
            sorted.push(commandSet);
        }
    }
    return sorted;
}
const orders = {
    ios: [
        // dangerous runs first
        'dangerous',
        // run the XcodeProject mod second because many plugins attempt to read from it.
        'xcodeproj',
    ],
    android: ['dangerous'],
};
/**
 * A generic plugin compiler.
 *
 * @param config
 */
async function evalModsAsync(config, { projectRoot, introspect, platforms, 
/**
 * Throw errors when mods are missing providers.
 * @default true
 */
assertMissingModProviders, }) {
    var _a, _b;
    for (const [platformName, platform] of Object.entries((_a = config.mods) !== null && _a !== void 0 ? _a : {})) {
        if (platforms && !platforms.includes(platformName)) {
            continue;
        }
        let entries = Object.entries(platform);
        if (entries.length) {
            // Move dangerous item to the first position if it exists, this ensures that all dangerous code runs first.
            entries = sortMods(entries, orders[platformName]);
            const platformProjectRoot = path_1.default.join(projectRoot, platformName);
            const projectName = platformName === 'ios' ? Xcodeproj_1.getHackyProjectName(projectRoot, config) : undefined;
            for (const [modName, mod] of entries) {
                const modRequest = {
                    projectRoot,
                    projectName,
                    platformProjectRoot,
                    platform: platformName,
                    modName,
                    introspect: !!introspect,
                };
                if (!mod.isProvider) {
                    // In strict mode, throw an error.
                    const errorMessage = `Initial base modifier for "${platformName}.${modName}" is not a provider and therefore will not provide modResults to child mods`;
                    if (assertMissingModProviders !== false) {
                        throw new errors_1.PluginError(errorMessage, 'MISSING_PROVIDER');
                    }
                    else {
                        if ((_b = config._internal) === null || _b === void 0 ? void 0 : _b.isDebug) {
                            console.warn(errorMessage);
                        }
                        // In loose mode, just skip the mod entirely.
                        continue;
                    }
                }
                const results = await mod({
                    ...config,
                    modResults: null,
                    modRequest,
                });
                // Sanity check to help locate non compliant mods.
                config = createBaseMod_1.assertModResults(results, platformName, modName);
                // @ts-ignore: data is added for modifications
                delete config.modResults;
                // @ts-ignore: info is added for modifications
                delete config.modRequest;
            }
        }
    }
    return config;
}
exports.evalModsAsync = evalModsAsync;
//# sourceMappingURL=mod-compiler.js.map