{"version":3,"file":"evalConfig.js","sourceRoot":"","sources":["../src/evalConfig.ts"],"names":[],"mappings":";;;;;;AAAA,aAAa;AACb,8EAAgD;AAGhD,qCAAuC;AACvC,2CAAoD;AACpD,qDAAkD;AAOlD;;;;;;GAMG;AACH,SAAgB,UAAU,CACxB,UAAkB,EAClB,OAA6B;IAE7B,MAAM,KAAK,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;IAErC,MAAM,EAAE,IAAI,EAAE,GAAG,KAAK,CAAC,iBAAiB,CAAC,UAAU,EAAE;QACnD,sBAAsB;QACtB,GAAG,EAAE,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,KAAI,OAAO,CAAC,GAAG,EAAE;QAC1C,OAAO,EAAE,KAAK;QACd,UAAU,EAAE,KAAK;QACjB,QAAQ,EAAE,KAAK;QACf,MAAM,EAAE,CAAC,cAAc,CAAC;QACxB,QAAQ,EAAE,SAAS;QACnB,OAAO,EAAE,CAAC,+BAAc,EAAE,CAAC;KAC5B,CAAC,CAAC;IAEH,MAAM,MAAM,GAAG,6BAAa,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IAC/C,OAAO,mBAAmB,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;AAC1D,CAAC;AAnBD,gCAmBC;AAED;;;;;;;;;GASG;AACH,SAAgB,mBAAmB,CACjC,MAAW,EACX,UAAkB,EAClB,OAA6B;IAE7B,IAAI,MAAM,CAAC,OAAO,IAAI,IAAI,EAAE;QAC1B,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC;KACzB;IACD,MAAM,kBAAkB,GAAG,OAAO,MAAM,CAAC;IACzC,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;QAChC,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;KAC1B;IAED,IAAI,MAAM,YAAY,OAAO,EAAE;QAC7B,MAAM,IAAI,oBAAW,CAAC,eAAe,UAAU,2BAA2B,EAAE,gBAAgB,CAAC,CAAC;KAC/F;IAED,sDAAsD;IACtD,IAAI,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,IAAI,EAAE;QAChB,MAAM,GAAG,iCAAqB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KAC7C;SAAM;QACL,MAAM,GAAG,iCAAqB,CAAC,MAAM,CAAC,CAAC;KACxC;IAED,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,kBAAkB,EAAE,CAAC;AAChD,CAAC;AAzBD,kDAyBC","sourcesContent":["// @ts-ignore\nimport requireString from 'require-from-string';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { serializeSkippingMods } from './Serialize';\nimport { getBabelPreset } from './getBabelPreset';\n// import babel from '@babel/core';\n\ntype RawDynamicConfig = AppJSONConfig | Partial<ExpoConfig> | null;\n\nexport type DynamicConfigResults = { config: RawDynamicConfig; exportedObjectType: string };\n\n/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */\nexport function evalConfig(\n  configFile: string,\n  request: ConfigContext | null\n): DynamicConfigResults {\n  const babel = require('@babel/core');\n\n  const { code } = babel.transformFileSync(configFile, {\n    // only: [configFile],\n    cwd: request?.projectRoot || process.cwd(),\n    babelrc: false,\n    configFile: false,\n    comments: false,\n    ignore: [/node_modules/],\n    filename: 'unknown',\n    presets: [getBabelPreset()],\n  });\n\n  const result = requireString(code, configFile);\n  return resolveConfigExport(result, configFile, request);\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */\nexport function resolveConfigExport(\n  result: any,\n  configFile: string,\n  request: ConfigContext | null\n) {\n  if (result.default != null) {\n    result = result.default;\n  }\n  const exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n\n  // If the expo object exists, ignore all other values.\n  if (result?.expo) {\n    result = serializeSkippingMods(result.expo);\n  } else {\n    result = serializeSkippingMods(result);\n  }\n\n  return { config: result, exportedObjectType };\n}\n"]}